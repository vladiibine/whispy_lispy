# -*- coding utf-8 -*-
"""
Will receive and interpret an abstract syntax tree (generated by the parser)
"""
from __future__ import unicode_literals

from whispy_lispy import ast

def interpret(ast, scope={}):
    """
    :param ast: An abstract syntax tree - generated by the parser
    :param scope: The scope where to interpret the abstract syntax tree
    :return: The value of the evaluation
    """
    if not ast:
        return

    result = None
    for elem in ast:
        if hasattr(elem, 'eval'):
            result = elem.eval(scope)
        # TODO - parser must return only evaluable objects
        else:
            result = elem

    return result


def interpret_ast(tree, scope=None):
    """Interpret the provided Abstract Syntax Tree within the given scope

    :param ast.AbstractSyntaxNode tree: the tree
    :param dict scope: The global scope
    :return: some value that results from the evaluation
    """
    result = None

    if scope is None:
        scope = {}

    if tree.is_leaf():
        return interpret_leaf(tree, scope)

    if isinstance(tree, ast.Apply):
        return interpret_apply(tree, scope)

    if isinstance(tree, ast.Assign):
        return interpret_assign(tree, scope)

    for elem in tree.values:
        result = interpret_ast(elem, scope)

    return result


def interpret_leaf(tree, scope):
    """Interpret the leaf nodes

    :param tree:
    :param scope:
    :return:
    """
    if tree.is_evaluable():
        if isinstance(tree, ast.Symbol):
            return scope[tree[0]]
        elif isinstance(tree, ast.Literal):
            return tree[0]


def interpret_assign(tree, scope):
    """Interpret a global assignment operation"""
    if not isinstance(tree[0], ast.Symbol):
        raise Exception('Should only assign to symbols')
    if isinstance(tree[1], ast.Literal):
        scope[tree[0][0]] = tree[1][0]
    elif isinstance(tree[1], ast.Symbol):
        scope[tree[0][0]] = scope[tree[1][0]]


